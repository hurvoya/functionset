import pandas as pd
import numpy as np

def compute_dealer_snapshot_metrics(
    df_base: pd.DataFrame,
    snapshots: list[pd.Timestamp],
    method: str = "yoy",          # "yoy" ou "prev6m"
    window_months: int = 6
) -> pd.DataFrame:
    """
    Calcule prod_current_6m et prod_prev_6m pour chaque snapshot, par (country, id_apporteur).
    df_base doit contenir: country, id_apporteur, dte_mel, mtd_total_lot
    """

    assert method in ("yoy", "prev6m")
    df = df_base.copy()

    # sécurité types
    df["dte_mel"] = pd.to_datetime(df["dte_mel"], errors="coerce")
    df = df[df["dte_mel"].notna()].copy()
    df["mtd_total_lot"] = pd.to_numeric(df["mtd_total_lot"], errors="coerce").fillna(0)

    out = []

    for S in snapshots:
        S = pd.Timestamp(S)

        # fenêtre courante [S-6m+1d, S]
        current_start = (S - pd.DateOffset(months=window_months)) + pd.Timedelta(days=1)
        current_end = S

        # fenêtre prev selon méthode
        if method == "prev6m":
            prev_start = current_start - pd.DateOffset(months=window_months)
            prev_end = current_end - pd.DateOffset(months=window_months)
        else:  # yoy
            prev_start = current_start - pd.DateOffset(months=12)
            prev_end = current_end - pd.DateOffset(months=12)

        # --- current
        cur = df[(df["dte_mel"] >= current_start) & (df["dte_mel"] <= current_end)]
        cur_agg = (
            cur.groupby(["country", "id_apporteur"])
               .agg(
                   prod_current_6m=("mtd_total_lot", "sum"),
                   nb_contracts_current_6m=("id_apporteur", "size")
               )
               .reset_index()
        )

        # --- prev
        prv = df[(df["dte_mel"] >= prev_start) & (df["dte_mel"] <= prev_end)]
        prv_agg = (
            prv.groupby(["country", "id_apporteur"])
               .agg(
                   prod_prev_6m=("mtd_total_lot", "sum"),
                   nb_contracts_prev_6m=("id_apporteur", "size")
               )
               .reset_index()
        )

        # merge current/prev
        m = cur_agg.merge(prv_agg, on=["country", "id_apporteur"], how="outer")

        # remplir les manquants
        for col in ["prod_current_6m", "prod_prev_6m", "nb_contracts_current_6m", "nb_contracts_prev_6m"]:
            if col in m.columns:
                m[col] = m[col].fillna(0)

        # growth_pct (NaN si prev=0)
        m["growth_pct"] = np.where(
            m["prod_prev_6m"] > 0,
            (m["prod_current_6m"] - m["prod_prev_6m"]) / m["prod_prev_6m"],
            np.nan
        )

        m["snapshot_date"] = S
        m["method"] = method

        out.append(m)

    res = pd.concat(out, ignore_index=True)

    # ordre colonnes
    cols_order = [
        "snapshot_date", "method", "country", "id_apporteur",
        "prod_current_6m", "prod_prev_6m", "growth_pct",
        "nb_contracts_current_6m", "nb_contracts_prev_6m"
    ]
    cols_order = [c for c in cols_order if c in res.columns]
    res = res[cols_order].copy()

    return res


# ✅ Exemple d’exécution
metrics_yoy = compute_dealer_snapshot_metrics(df_base, snapshots, method="yoy")
metrics_prev6m = compute_dealer_snapshot_metrics(df_base, snapshots, method="prev6m")

print(metrics_yoy.shape, metrics_prev6m.shape)
print(metrics_yoy.head())
