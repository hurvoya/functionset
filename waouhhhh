import pandas as pd
import numpy as np

# --------------------------
# Utils dates
# --------------------------
def to_datetime(df: pd.DataFrame, cols):
    for c in cols:
        if c in df.columns:
            df[c] = pd.to_datetime(df[c], errors="coerce")
    return df

def month_end(s: pd.Series) -> pd.Series:
    # convertit une date en fin de mois
    return (s.dt.to_period("M").dt.to_timestamp("M"))

# --------------------------
# 1) Détecter les événements New Dealer (D)
# --------------------------
def compute_new_dealer_events(
    df_contract: pd.DataFrame,
    dealer_col="id_apporteur",
    country_col="country",
    contract_id_col="id_contract",
    mel_col="dte_mel",
    fin_col="dte_fin_contrat",
    lookback_months=12,
) -> pd.DataFrame:
    """
    Retourne un DF d'événements :
    - date_new_dealer = MEL d'un contrat déclencheur
    - type : first_time / known
    Condition déclencheur : aucune activité "en vie" dans les 12 mois précédents.
    Approche :
      Pour un contrat à date mel = D :
        il existe un contrat précédent "en vie" dans [D-12m, D) si
          (fin_prev >= D-12m) AND (mel_prev < D)
      Donc déclencheur si max(fin_prev) < D-12m.
    """
    dfc = df_contract.copy()
    dfc = dfc.dropna(subset=[dealer_col, mel_col])  # besoin au minimum de dealer et dte_mel
    dfc = dfc.sort_values([country_col, dealer_col, mel_col])

    # Pour un dealer, on calcule le "rolling max" des dte_fin_contrat des contrats précédents
    # rolling_max_fin_prev = max(fin) sur les lignes précédentes
    dfc["rolling_max_fin_prev"] = (
        dfc.groupby([country_col, dealer_col])[fin_col]
           .cummax()
           .shift(1)
    )

    # Savoir s'il existe un contrat précédent (pour distinguer first_time vs known)
    dfc["has_prev_contract"] = dfc.groupby([country_col, dealer_col]).cumcount() > 0

    # Seuil lookback
    dfc["lookback_start"] = dfc[mel_col] - pd.DateOffset(months=lookback_months)

    # Déclencheur si PAS de contrat en vie dans les 12 mois précédents
    # i.e. rolling_max_fin_prev < lookback_start OU rolling_max_fin_prev is NaT (aucun précédent)
    trigger = dfc["rolling_max_fin_prev"].isna() | (dfc["rolling_max_fin_prev"] < dfc["lookback_start"])
    events = dfc.loc[trigger, [country_col, dealer_col, mel_col, "has_prev_contract"]].copy()
    events = events.rename(columns={mel_col: "date_new_dealer"})

    events["new_dealer_type"] = np.where(events["has_prev_contract"], "known", "first_time")

    # Identifiant d'événement (utile pour les merges et les fenêtres)
    events = events.sort_values([country_col, dealer_col, "date_new_dealer"])
    events["event_id"] = (
        events.groupby([country_col, dealer_col]).cumcount() + 1
    )

    events = events.drop(columns=["has_prev_contract"])
    return events


# --------------------------
# 2) Construire la timeline mensuelle (fin de mois) pour chaque événement
# --------------------------
def build_event_month_timeline(events: pd.DataFrame, months_follow=6) -> pd.DataFrame:
    """
    1 ligne = 1 event_id × 1 mois de suivi
    On crée months_follow points mensuels (par défaut 6) à partir du mois de date_new_dealer (inclus).
    """
    ev = events.copy()
    # mois 0 = fin du mois de D
    ev["start_month_end"] = month_end(ev["date_new_dealer"])

    # construire 6 mois : m_idx=0..5
    all_rows = []
    for m in range(months_follow):
        tmp = ev[[c for c in ev.columns if c not in ["start_month_end"]]].copy()
        tmp["m_idx"] = m
        tmp["mois_ref"] = ev["start_month_end"] + pd.offsets.MonthEnd(m)
        all_rows.append(tmp)

    timeline = pd.concat(all_rows, ignore_index=True)
    return timeline


# --------------------------
# 3) Associer les contrats à un événement (fenêtre 6 mois) et cap 8 contrats
# --------------------------
def attach_contracts_to_events(
    df_contract: pd.DataFrame,
    events: pd.DataFrame,
    dealer_col="id_apporteur",
    country_col="country",
    contract_id_col="id_contract",
    mel_col="dte_mel",
    fin_col="dte_fin_contrat",
    amount_col="mtd_total_lot",
    partner_col="lib_partner",
    ibl_col="ibl",
    months_follow=6,
    cap_contracts=8,
) -> pd.DataFrame:
    """
    Produit un DF "contrats suivis" :
    - chaque contrat est rattaché à l'événement du dealer (event_id) si dte_mel dans [D, D+6mois)
    - on classe les contrats dans la fenêtre par dte_mel et on garde les 8 premiers (cap)
    Ces contrats = calls potentiels.
    """
    dfc = df_contract.copy()
    dfc = dfc.dropna(subset=[dealer_col, mel_col])

    ev = events.copy()
    ev["end_follow_date"] = ev["date_new_dealer"] + pd.DateOffset(months=months_follow)

    # Merge "large" dealer -> events
    # Les events ne se chevauchent normalement pas, mais on filtre ensuite par fenêtre.
    merged = dfc.merge(
        ev[[country_col, dealer_col, "event_id", "date_new_dealer", "end_follow_date", "new_dealer_type"]],
        on=[country_col, dealer_col],
        how="inner",
        suffixes=("", "_ev"),
    )

    # Filtre fenêtre [D, D+6mois)
    in_window = (merged[mel_col] >= merged["date_new_dealer"]) & (merged[mel_col] < merged["end_follow_date"])
    merged = merged.loc[in_window].copy()

    # Ranger par event + dte_mel, numéroter
    merged = merged.sort_values([country_col, dealer_col, "event_id", mel_col, contract_id_col])
    merged["seq_in_follow"] = merged.groupby([country_col, dealer_col, "event_id"]).cumcount() + 1

    # cap 8
    merged["is_called"] = merged["seq_in_follow"] <= cap_contracts
    merged = merged.loc[merged["is_called"]].copy()

    # Mois (fin de mois) du contrat pour agrégation mensuelle
    merged["mois_contrat"] = month_end(merged[mel_col])

    keep_cols = [
        country_col, dealer_col, "event_id", "date_new_dealer", "new_dealer_type",
        contract_id_col, mel_col, fin_col, amount_col, "seq_in_follow", "mois_contrat"
    ]
    if partner_col in merged.columns: keep_cols.append(partner_col)
    if ibl_col in merged.columns: keep_cols.append(ibl_col)

    return merged[keep_cols].copy()


# --------------------------
# 4) Construire le stock mensuel (timeline + agrégats calls/montants + contexte à date)
# --------------------------
def build_monthly_stock(
    df_contract: pd.DataFrame,
    timeline: pd.DataFrame,
    followed_contracts: pd.DataFrame,
    dealer_col="id_apporteur",
    country_col="country",
    contract_id_col="id_contract",
    mel_col="dte_mel",
    amount_col="mtd_total_lot",
    partner_col="lib_partner",
    ibl_col="ibl",
):
    """
    timeline : 1 event_id x mois_ref
    followed_contracts : contrats dans fenêtre + cap 8 (donc calls)
    Contexte "actuel" au mois_ref : dernier contrat connu <= mois_ref (tous contrats, pas que la fenêtre)
    """
    # A) agrégats calls/montants sur contrats suivis (cap 8)
    fc = followed_contracts.copy()

    # Agrégat mensuel
    agg_m = (
        fc.groupby([country_col, dealer_col, "event_id", "mois_contrat"])
          .agg(
              nb_contrats_mois=(contract_id_col, "count"),
              montant_finance_mois=(amount_col, "sum"),
          )
          .reset_index()
          .rename(columns={"mois_contrat": "mois_ref"})
    )

    # Pour les cumuls : on joint timeline + contrats suivis et on cumule par mois_ref
    # Méthode : merge puis cumcount / cumsum par event trié par mois_ref
    stock = timeline.merge(
        agg_m,
        on=[country_col, dealer_col, "event_id", "mois_ref"],
        how="left"
    )

    stock["nb_contrats_mois"] = stock["nb_contrats_mois"].fillna(0).astype(int)
    stock["montant_finance_mois"] = stock["montant_finance_mois"].fillna(0.0)

    stock = stock.sort_values([country_col, dealer_col, "event_id", "mois_ref"])
    stock["nb_contrats_cum"] = stock.groupby([country_col, dealer_col, "event_id"])["nb_contrats_mois"].cumsum()
    stock["montant_finance_cum"] = stock.groupby([country_col, dealer_col, "event_id"])["montant_finance_mois"].cumsum()

    # Calls = contrats suivis (cap 8) => identiques ici
    stock["nb_calls_mois"] = stock["nb_contrats_mois"]
    stock["nb_calls_cum"] = stock["nb_contrats_cum"]

    # B) Contexte "dernier contrat à date"
    # On prend le dernier contrat (tous contrats) avec dte_mel <= mois_ref
    dfc = df_contract.copy()
    dfc = dfc.dropna(subset=[dealer_col, mel_col])
    dfc["mois_ref"] = month_end(dfc[mel_col])

    # Pour pouvoir faire "dernier contrat <= mois_ref", on utilise merge_asof par dealer/pays sur dates
    # On crée une table des contrats triée par date_mel, et on asof-merge sur la "date de fin de mois"
    dfc_sorted = dfc.sort_values([country_col, dealer_col, mel_col])

    stock_sorted = stock.sort_values([country_col, dealer_col, "mois_ref"])

    # merge_asof exige tri global, on le fait par groupe via concat
    out_parts = []
    for (cty, dealer), sub_stock in stock_sorted.groupby([country_col, dealer_col], sort=False):
        sub_contracts = dfc_sorted[(dfc_sorted[country_col] == cty) & (dfc_sorted[dealer_col] == dealer)].copy()
        sub_contracts = sub_contracts.sort_values(mel_col)
        sub_stock = sub_stock.sort_values("mois_ref")

        if sub_contracts.empty:
            # aucun contrat => pas de contexte
            sub_stock["partner_actuel"] = np.nan
            sub_stock["ibl_actuel"] = np.nan
            out_parts.append(sub_stock)
            continue

        # asof: pour chaque mois_ref, prendre la dernière ligne dont dte_mel <= mois_ref
        merged_ctx = pd.merge_asof(
            sub_stock,
            sub_contracts[[mel_col, partner_col, ibl_col]].rename(columns={mel_col: "dte_mel_ctx"}),
            left_on="mois_ref",
            right_on="dte_mel_ctx",
            direction="backward",
        )
        merged_ctx = merged_ctx.drop(columns=["dte_mel_ctx"])
        merged_ctx = merged_ctx.rename(columns={partner_col: "partner_actuel", ibl_col: "ibl_actuel"})
        out_parts.append(merged_ctx)

    stock = pd.concat(out_parts, ignore_index=True)

    # C) Key account flag (utilisé pour analyse 1 et pour filtrer le reste)
    stock["is_key_account"] = stock["partner_actuel"].notna() & (stock["partner_actuel"] != "Not Allocated")

    # D) Suivi (à ce stade, notre timeline ne contient que 6 mois)
    # Mais si cap 8 atteint tôt, les mois suivants ne doivent plus être "en_suivi".
    stock["en_suivi"] = stock["nb_contrats_cum"] < 8
    stock["sorti_du_suivi"] = ~stock["en_suivi"]

    return stock


# --------------------------
# Pipeline complet
# --------------------------
def build_dealer_stock_pipeline(
    df: pd.DataFrame,
    dealer_col="id_apporteur",
    country_col="country",
    contract_id_col="id_contract",
    mel_col="dte_mel",
    fin_col="dte_fin_contrat",
    amount_col="mtd_total_lot",
    partner_col="lib_partner",
    ibl_col="ibl",
):
    # 0) dates
    df = df.copy()
    df = to_datetime(df, [mel_col, fin_col])

    # 1) events
    events = compute_new_dealer_events(
        df, dealer_col=dealer_col, country_col=country_col,
        contract_id_col=contract_id_col, mel_col=mel_col, fin_col=fin_col,
        lookback_months=12
    )

    # 2) timeline mois (6)
    timeline = build_event_month_timeline(events, months_follow=6)

    # 3) contrats suivis (fenêtre 6 mois + cap 8)
    followed = attach_contracts_to_events(
        df, events,
        dealer_col=dealer_col, country_col=country_col,
        contract_id_col=contract_id_col, mel_col=mel_col, fin_col=fin_col,
        amount_col=amount_col, partner_col=partner_col, ibl_col=ibl_col,
        months_follow=6, cap_contracts=8
    )

    # 4) stock mensuel
    stock = build_monthly_stock(
        df, timeline, followed,
        dealer_col=dealer_col, country_col=country_col,
        contract_id_col=contract_id_col, mel_col=mel_col,
        amount_col=amount_col, partner_col=partner_col, ibl_col=ibl_col
    )

    return events, followed, stock
