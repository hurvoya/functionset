# --- prérequis cutoffs: today / cutoff_6y / cutoff_12m déjà définis ---

# 1) Prépare une hashmap client_id -> SIREN
siren_map = (
    df_client.loc[df_client["client_siren"].notna(), ["client_id", "client_siren"]]
    .drop_duplicates("client_id")
    .set_index("client_id")["client_siren"]
)

# 2) Filtrer df_request avec les client_id connus (semi-join)
client_ids = siren_map.index  # Index unique et compact
req_small = df_request.loc[
    df_request["request_client_id"].isin(client_ids),
    ["request_client_id", "request_last_modification_date", "request_status"]
].copy()

# (optionnel) dtypes pour gagner de la RAM
if req_small["request_status"].dtype != "category":
    req_small["request_status"] = req_small["request_status"].astype("category")

# 3) RÈGLE 2 — aucune demande modifiée < 12 mois
#    Agrégat au niveau client → max date de modif
last_mod_by_client = (
    req_small.groupby("request_client_id", observed=True)["request_last_modification_date"]
    .max()
)

#    Ramener au SIREN puis consolider
last_mod_by_siren = (
    last_mod_by_client
    .to_frame(name="req_last_mod_max")
    .assign(SIREN=lambda d: siren_map.reindex(d.index).values)
    .dropna(subset=["SIREN"])
    .groupby("SIREN", observed=True)["req_last_mod_max"].max()
)

tiers_flags["req_last_mod_max"] = tiers_flags["SIREN"].map(last_mod_by_siren)
tiers_flags["flag_2_no_req_12m"] = (
    tiers_flags["req_last_mod_max"].lt(cutoff_12m) | tiers_flags["req_last_mod_max"].isna()
).astype(int)
tiers_flags.drop(columns=["req_last_mod_max"], inplace=True)

# 4) RÈGLE 3 — si ACC existe, dernière modif ACC ≥ 6 ans
req_acc = req_small.loc[req_small["request_status"].cat.codes == req_small["request_status"].cat.categories.get_loc("ACC")] \
          if "ACC" in list(req_small["request_status"].cat.categories) else req_small.iloc[0:0]

# Variante plus lisible (un peu moins rapide) :
# req_acc = req_small[req_small["request_status"] == "ACC"]

acc_last_mod_by_client = (
    req_acc.groupby("request_client_id", observed=True)["request_last_modification_date"]
    .max()
)

acc_last_mod_by_siren = (
    acc_last_mod_by_client
    .to_frame(name="acc_last_mod_max")
    .assign(SIREN=lambda d: siren_map.reindex(d.index).values)
    .dropna(subset=["SIREN"])
    .groupby("SIREN", observed=True)["acc_last_mod_max"].max()
)

tiers_flags["acc_last_mod_max"] = tiers_flags["SIREN"].map(acc_last_mod_by_siren)
tiers_flags["flag_3_ACC_6y"] = (
    tiers_flags["acc_last_mod_max"].le(cutoff_6y) | tiers_flags["acc_last_mod_max"].isna()
).astype(int)
tiers_flags.drop(columns=["acc_last_mod_max"], inplace=True)

# 5) Met à jour le flag final
tiers_flags["flag_eligible_purge"] = (
    tiers_flags[["flag_1_TER_6y", "flag_2_no_req_12m", "flag_3_ACC_6y", "flag_4_contentieux_arch_6y"]]
    .all(axis=1)
    .astype(int)
)
