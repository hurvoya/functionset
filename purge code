# --- Prérequis : mêmes cutoffs que plus haut ---
# today = pd.Timestamp.today().normalize()
# cutoff_6y  = today - pd.DateOffset(years=6)
# cutoff_12m = today - pd.DateOffset(months=12)

# 0) Hygiène / dtypes
if df_request["request_status"].dtype != "category":
    df_request["request_status"] = df_request["request_status"].astype("category")
df_request["request_client_id"] = df_request["request_client_id"].astype(df_client["client_id"].dtype, copy=False)

# 1) Hashmap client_id -> SIREN (aucun reindex, index unique)
siren_map = (
    df_client.loc[df_client["client_siren"].notna(), ["client_id", "client_siren"]]
    .drop_duplicates("client_id")
    .set_index("client_id")["client_siren"]
)

# 2) RÈGLE 2 — aucune demande modifiée dans les 12 derniers mois
#    Agrégat par client puis consolidation par SIREN
last_mod_by_client = (
    df_request.groupby("request_client_id", observed=True)["request_last_modification_date"]
    .max()
)

last_mod_by_siren = (
    last_mod_by_client
    .to_frame(name="req_last_mod_max")
    .assign(SIREN=lambda d: siren_map.map(d.index).values)   # map plutôt que reindex
    .dropna(subset=["SIREN"])
    .groupby("SIREN", observed=True)["req_last_mod_max"].max()
)

# Injection via map (aucun reindex, tolère les doublons dans tiers_flags["SIREN"])
tiers_flags["req_last_mod_max"] = tiers_flags["SIREN"].map(last_mod_by_siren)
tiers_flags["flag_2_no_req_12m"] = (
    tiers_flags["req_last_mod_max"].lt(cutoff_12m) | tiers_flags["req_last_mod_max"].isna()
).astype(int)
tiers_flags.drop(columns=["req_last_mod_max"], inplace=True)

# 3) RÈGLE 3 — si ACC présent, dernière modif ACC ≥ 6 ans
acc_last_mod_by_client = (
    df_request.loc[df_request["request_status"] == "ACC"]
    .groupby("request_client_id", observed=True)["request_last_modification_date"]
    .max()
)

acc_last_mod_by_siren = (
    acc_last_mod_by_client
    .to_frame(name="acc_last_mod_max")
    .assign(SIREN=lambda d: siren_map.map(d.index).values)   # map plutôt que reindex
    .dropna(subset=["SIREN"])
    .groupby("SIREN", observed=True)["acc_last_mod_max"].max()
)

tiers_flags["acc_last_mod_max"] = tiers_flags["SIREN"].map(acc_last_mod_by_siren)
tiers_flags["flag_3_ACC_6y"] = (
    tiers_flags["acc_last_mod_max"].le(cutoff_6y) | tiers_flags["acc_last_mod_max"].isna()
).astype(int)
tiers_flags.drop(columns=["acc_last_mod_max"], inplace=True)

# 4) Recalcule éventuel du flag final
tiers_flags["flag_eligible_purge"] = (
    tiers_flags[["flag_1_TER_6y", "flag_2_no_req_12m", "flag_3_ACC_6y", "flag_4_contentieux_arch_6y"]]
    .all(axis=1)
    .astype(int)
)
