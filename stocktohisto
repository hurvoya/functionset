Un contrat est en vie pour un mois de stock M si et seulement si :

date_debut < 1er jour du mois M

date_fin â‰¥ 1er jour du mois M + 1 mois

ðŸ’¡ Donc :

Il faut que le contrat ait commencÃ© avant le mois, pas pendant.

Et quâ€™il soit encore actif aprÃ¨s la fin du mois, donc fin â‰¥ 1er du mois suivant.

On exclut les NaT en date_fin (ils ne sont pas traitÃ©s).



import pandas as pd
from datetime import datetime
import numpy as np

# Exemple de base historique
df = pd.DataFrame({
    'id_contrat': [1, 2, 3, 4],
    'date_debut': [pd.Timestamp('2022-01-23'), pd.Timestamp('2023-06-01'),
                   pd.Timestamp('2024-03-15'), pd.Timestamp('2023-01-15')],
    'date_fin': [pd.Timestamp('2027-01-23'), pd.Timestamp('2024-10-01'),
                 pd.NaT, pd.Timestamp('2023-01-14')]
})

# Supprimer les contrats sans date_fin
df = df.dropna(subset=['date_fin'])

# Date de rÃ©fÃ©rence : avril 2025
today = pd.Timestamp('2025-04-01')

# GÃ©nÃ©rer les 13 mois glissants de mars 2024 Ã  mars 2025
mois_stock = pd.date_range(end=today - pd.offsets.MonthBegin(1), periods=13, freq='MS')

# CrÃ©ation de toutes les combinaisons contrat x mois
df_cross = df.assign(key=1).merge(
    pd.DataFrame({'mois': mois_stock, 'key': 1}),
    on='key'
).drop(columns='key')

# Calcul du 1er jour du mois suivant pour chaque mois M
df_cross['debut_mois'] = df_cross['mois']
df_cross['debut_mois_suivant'] = df_cross['mois'] + pd.offsets.MonthBegin(1)

# Application de la condition stricte :
# date_debut < 1er M ET date_fin â‰¥ 1er M+1
df_stock = df_cross[
    (df_cross['date_debut'] < df_cross['debut_mois']) &
    (df_cross['date_fin'] >= df_cross['debut_mois_suivant'])
][['mois', 'id_contrat']].sort_values(['mois', 'id_contrat'])

# Affichage final
print(df_stock)
